<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8">
  <title>3D Modell – Cesium</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

  <style>
    html, body, #cesiumContainer { width:100%; height:100%; margin:0; padding:0; }
    .toolbar {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 8px;
      border-radius: 5px;
      font-family: sans-serif;
      z-index: 100;
    }
    .toolbar button {
      margin: 3px;
      padding: 5px 10px;
      background: #0078d7;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .toolbar button:hover { background: #005a9e; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <div class="toolbar">
    <button id="distanceBtn">Avstånd</button>
    <button id="areaBtn">Area</button>
    <button id="angleBtn">Lutning</button>
  </div>

  <script>
    // Din Cesium token och 3D-modell assetId
    Cesium.Ion.defaultAccessToken = "DIN_TOKEN_HÄR";
    const assetId = DIN_ASSETID_HÄR;

    // Skapa viewer med ljus bakgrund och navigationskompass
    const viewer = new Cesium.Viewer("cesiumContainer", {
      timeline: false,
      animation: false,
      baseLayerPicker: false,
      sceneModePicker: true,
      navigationHelpButton: true,
      homeButton: true,
      infoBox: true,
      selectionIndicator: true,
      skyBox: false,
      skyAtmosphere: false,
      imageryProvider: false,
      backgroundColor: Cesium.Color.LIGHTGRAY
    });

    // Lägg till modellen
    let tileset;
    Cesium.Cesium3DTileset.fromIonAssetId(assetId).then(t => {
      tileset = t;
      viewer.scene.primitives.add(tileset);

      // Zooma till modellen
      const bs = tileset.boundingSphere;
      viewer.camera.viewBoundingSphere(bs, new Cesium.HeadingPitchRange(0, -0.3, bs.radius*1.5));

      // Home-knapp centrerad
      viewer.homeButton.viewModel.command.beforeExecute.addEventListener(e=>{
        e.cancel = true;
        viewer.camera.viewBoundingSphere(bs, new Cesium.HeadingPitchRange(0,-0.3,bs.radius*1.5));
      });
    });

    // ===========================================
    // Visuella mätverktyg
    // ===========================================
    let activeHandler = null;
    let measurementPoints = [];
    let measurementEntities = [];

    function clearMeasurements() {
      measurementPoints = [];
      measurementEntities.forEach(e => viewer.entities.remove(e));
      measurementEntities = [];
      if(activeHandler) {
        activeHandler.destroy();
        activeHandler = null;
      }
    }

    function startDistance() {
      clearMeasurements();
      activeHandler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
      activeHandler.setInputAction(function(click){
        const pos = viewer.scene.pickPosition(click.position);
        if(!pos) return;
        const entity = viewer.entities.add({
          position: pos,
          point: { pixelSize:5, color:Cesium.Color.RED }
        });
        measurementEntities.push(entity);
        measurementPoints.push(pos);
        if(measurementPoints.length===2){
          const line = viewer.entities.add({
            polyline:{
              positions: measurementPoints,
              width:3,
              material: Cesium.Color.RED
            }
          });
          measurementEntities.push(line);
          const d = Cesium.Cartesian3.distance(measurementPoints[0], measurementPoints[1]);
          const mid = Cesium.Cartesian3.midpoint(measurementPoints[0], measurementPoints[1], new Cesium.Cartesian3());
          const label = viewer.entities.add({
            position: mid,
            label:{ text: d.toFixed(2)+" m", fillColor: Cesium.Color.RED, font:"16px sans-serif" }
          });
          measurementEntities.push(label);
          activeHandler.destroy();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }

    function startArea() {
      clearMeasurements();
      activeHandler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
      activeHandler.setInputAction(function(click){
        const pos = viewer.scene.pickPosition(click.position);
        if(!pos) return;
        const point = viewer.entities.add({position: pos, point:{pixelSize:5,color:Cesium.Color.BLUE}});
        measurementEntities.push(point);
        measurementPoints.push(pos);

        if(measurementPoints.length>=3){
          const poly = viewer.entities.add({
            polygon:{ hierarchy: measurementPoints.slice(), material: Cesium.Color.BLUE.withAlpha(0.3) }
          });
          measurementEntities.push(poly);

          // Beräkna area (approx planar)
          let area = 0;
          for(let i=1;i<measurementPoints.length-1;i++){
            const a = Cesium.Cartesian3.distance(measurementPoints[0], measurementPoints[i]);
            const b = Cesium.Cartesian3.distance(measurementPoints[i], measurementPoints[i+1]);
            const c = Cesium.Cartesian3.distance(measurementPoints[i+1], measurementPoints[0]);
            const s = (a+b+c)/2;
            area += Math.sqrt(s*(s-a)*(s-b)*(s-c));
          }
          const centroid = measurementPoints.reduce((acc,p)=>Cesium.Cartesian3.add(acc,p,new Cesium.Cartesian3()),new Cesium.Cartesian3());
          Cesium.Cartesian3.divideByScalar(centroid,measurementPoints.length,centroid);
          const label = viewer.entities.add({position: centroid,label:{text:area.toFixed(2)+" m²",fillColor:Cesium.Color.BLUE,font:"16px sans-serif"}});
          measurementEntities.push(label);
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }

    function startAngle() {
      clearMeasurements();
      activeHandler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
      activeHandler.setInputAction(function(click){
        const pos = viewer.scene.pickPosition(click.position);
        if(!pos) return;
        const point = viewer.entities.add({position: pos, point:{pixelSize:5,color:Cesium.Color.GREEN}});
        measurementEntities.push(point);
        measurementPoints.push(pos);

        if(measurementPoints.length===3){
          const v1 = Cesium.Cartesian3.subtract(measurementPoints[1],measurementPoints[0],new Cesium.Cartesian3());
          const v2 = Cesium.Cartesian3.subtract(measurementPoints[2],measurementPoints[0],new Cesium.Cartesian3());
          const angle = Cesium.Cartesian3.angleBetween(v1,v2)*180/Math.PI;
          const label = viewer.entities.add({
            position: measurementPoints[0],
            label:{text:angle.toFixed(2)+"°",fillColor:Cesium.Color.GREEN,font:"16px sans-serif"}
          });
          measurementEntities.push(label);
          activeHandler.destroy();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }

    document.getElementById("distanceBtn").onclick = startDistance;
    document.getElementById("areaBtn").onclick = startArea;
    document.getElementById("angleBtn").onclick = startAngle;

  </script>
</body>
</html>
